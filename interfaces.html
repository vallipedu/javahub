<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Interfaces: Foundation and Practical View</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #2c3e50;
        }

        h1 {
            text-align: center;
        }

        pre {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
        }

        .note {
            background: #e6f7ff;
            border-left: 5px solid #3498db;
            padding: 10px;
            margin: 20px 0;
        }

        ul {
            list-style-type: disc;
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        .code-title {
            font-style: italic;
            color: #7f8c8d;
        }

        /* Style for the back button */
        .back-button {
            display: inline-block;
            margin-top: 30px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }

        .back-button:hover {
            background-color: #2980b9;
        }

        /* Style for the footer */
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            font-size: 0.9em;
            color: #777;
        }

        footer a {
            color: #3498db;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <a href="index.html" class="back-button">Back to Home</a>
    <a href="interfacesSyllabus.html" class="back-button">Go to Assignment</a>
    <a href="inprogress.html" class="back-button">In Class Examples</a>

    <hr>
    <div class="container">
        <h1>NBKRIST JAVAHUB - Java Interfaces: A Foundation and Practical Guide</h1>
        <hr>
        <p>
            An <strong>interface</strong> in Java is a blueprint for a class. It defines a contract that specifies what
            a class must do, but not how it does it. Before Java 8, interfaces could only contain method signatures
            (abstract methods) and constant fields. Since Java 8, they can also include default and static methods.
        </p>

        <h2>What is an Interface? ü§î</h2>
        <p>
            Think of an interface as a formal agreement. If a class decides to <code>implement</code> an interface, it's
            making a promise to provide concrete implementations for all the abstract methods defined in that interface.
            This promotes a concept called <strong>abstraction</strong>, where you hide the complex implementation
            details and only show the necessary functionalities to the user.
        </p>
        <p>
            Key characteristics of a Java interface:
        </p>
        <ul>
            <li>By default, all methods in an interface are <strong>public</strong> and <strong>abstract</strong>.</li>
            <li>All variables are <strong>public</strong>, <strong>static</strong>, and <strong>final</strong> by
                default.</li>
            <li>Interfaces cannot be instantiated.</li>
            <li>A class can <code>implement</code> multiple interfaces.</li>
            <li>An interface can <code>extend</code> another interface.</li>
        </ul>

        <h2>How Java Achieves Multiple Inheritance with Interfaces</h2>
        <p>
            Unlike C++, Java does not support multiple inheritance of classes. This is primarily to avoid the "Diamond
            Problem."
            The diamond problem occurs when a class inherits from two superclasses that both have a method with the same
            name. It creates ambiguity for the compiler, which can't determine which version of the method to inherit.

            However, this problem is neatly avoided by using interfaces.
        </p>
        <p>
            Since interfaces only define a contract (a set of abstract methods) and not the implementation, there's no
            ambiguity when a class implements multiple interfaces. The implementing class itself provides the concrete
            implementation for each method.
            This allows a single class to adopt behaviors from multiple "parent" interfaces, effectively achieving
            <strong>multiple inheritance of behavior</strong>.
        </p>
        <p>
            Let's look at an example:
        </p>
        <pre><code class="language-java">
// Interface for a land vehicle
interface Walkable {
    void walk();
}

// Interface for a water vehicle
interface Swimmable {
    void swim();
}

// A class that can both walk and swim
class Duck implements Walkable, Swimmable {
    &#64;Override
    public void walk() {
        System.out.println("Duck is walking.");
    }
    
    &#64;Override
    public void swim() {
        System.out.println("Duck is swimming.");
    }
}
        </code></pre>
        <p>
            In the code above, the <code>Duck</code> class inherits the behaviors of both <code>Walkable</code> and
            <code>Swimmable</code>, providing its own implementation for each. There is no ambiguity because the
            implementation is explicitly provided by the <code>Duck</code> class itself.
        </p>
        <hr>
        <h2>Important Notes for Interview Preparation üìù</h2>

        <h3>1. Interface vs. Abstract Class</h3>
        <p>
            This is a very common interview question. While both are used to achieve abstraction, they have key
            differences:
        </p>
        <ul>
            <li><strong>Interface:</strong> Provides 100% abstraction (before Java 8). Cannot have constructors. A class
                can implement multiple interfaces.</li>
            <li><strong>Abstract Class:</strong> Can have both abstract and concrete (implemented) methods. Can have
                constructors. A class can only extend one abstract class. Use abstract classes when you need to share a
                common base implementation among subclasses.</li>
        </ul>

        <h3>2. Default and Static Methods (Java 8+)</h3>
        <p>
            Java 8 introduced <strong>default methods</strong> to interfaces. This was a significant change that allows
            developers to add new methods to an existing interface without breaking all the classes that implement it.
        </p>
        <p>
            Default methods are useful for backward compatibility. They have a default implementation that can be used
            by implementing classes, but can also be overridden.
        </p>
        <pre><code class="language-java">
interface Vehicle {
    void move();
    
    // Default method introduced in Java 8
    default void honk() {
        System.out.println("Honk!");
    }
}
        </code></pre>
        <p>
            <strong>Static methods</strong> in interfaces are utility methods that are tied to the interface itself, not
            to an implementing class or object. They are called using the interface name (e.g.,
            <code>InterfaceName.staticMethod()</code>).
        </p>

        <h3>3. Marker Interfaces</h3>
        <p>
            A <strong>marker interface</strong> is an interface that has no methods or fields. Its sole purpose is to
            "mark" a class with a certain capability. The Java Virtual Machine (JVM) then uses this information to
            perform some special operation on the class. Common examples include <code>Serializable</code> and
            <code>Cloneable</code>.
        </p>
        <pre><code class="language-java">
// This is a marker interface
public interface Serializable {
}
        </code></pre>
        <p>
            When a class implements <code>Serializable</code>, the JVM knows that objects of this class can be converted
            into a byte stream (serialized).
        </p>

        <h3>4. Loose Coupling and Polymorphism</h3>
        <p>
            Interfaces promote <strong>loose coupling</strong>, which means different parts of your code are less
            dependent on each other. You can program to an interface rather than to a concrete implementation.
        </p>
        <p>
            This also enables <strong>polymorphism</strong>. A variable of an interface type can hold a reference to any
            object that implements that interface. This makes your code flexible and easy to maintain.
        </p>
        <pre><code class="language-java">
// Using an interface type for polymorphism
List&lt;String&gt; myList = new ArrayList&lt;&gt;();
// The variable 'myList' is of type List, but its object is an ArrayList.
// You can later switch to a different implementation (e.g., LinkedList)
// without changing the code that uses 'myList'.
        </code></pre>
        <hr>
        <a href="index.html" class="back-button">Back to Home</a>
    </div>

    <footer>
        <p>&copy; 2025 NBKRIST JAVAHUB: all rights are reserved</p>
        <p><a href="https://www.nbkrist.co.in/index.php" target="_blank">Visit NBKRIST Website</a></p>
    </footer>
</body>

</html>
